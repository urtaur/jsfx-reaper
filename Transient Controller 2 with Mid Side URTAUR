desc:Transient Controller 2 with Mid Side URTAUR
author: Ersh
version: 2.1.4
changelog:
  Renamed processing modes: Mid Only -> Mid+, Side Only -> Side+
  Added new processing modes: Mid (pure mid), Side (pure side)
  Add gain smoothness parameter.
  Increased internal frame rate to 1500 for finer peak resolution.
  Performance optimization.
  Added Mid/Side volume controls.
  Added Mid/Side processing mode selector (affects entire processing).
screenshot: Screenshot https://i.imgur.com/UMMDxQI.png
about:
  # Transient Controller 2 with Mid/Side

  A basic improvement of the standard TransientController supplied with Reaper64.

  - Unhides internal parameters for finer adjustment.
  - Adds graphical visualisation: [screenshot](https://i.imgur.com/UMMDxQI.png).
  - Added Mid/Side volume controls for stereo image manipulation.
  - Added Mid/Side processing mode selector that affects entire transient processing.

// (C) 2007, Michael Gruhn.
// (C) 2021, Yury Ershov.

// NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL OR CONSEQUENTIAL DAMAGE ARISING
// OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// ENTRUST SOMEBODY ELSE WITH DOING SO.

// Further more is this released under the GPL License:
// http://www.gnu.org/licenses/gpl.html

//tags: processing dynamics transient
//author: LOSER, ERSH

slider1:0<-200,200,1>Attack (%)
slider2:0<-200,200,1>Sustain (%)
slider3:0<-12,6,.1>Output (dB)
slider4:-30<-1000,-.1,.1>Transient Detector decay
slider5:-1250<-10000,-.1,.1>Attack Detector decay
slider6:-3<-100,-.1,.1>Sustain Detector decay
slider7:0<0,1,1{No,Yes}>Use slow gain release
slider8:25<1,1000,.1>Gain Release Rate dB/sec
slider9:0<-24,24,0.1>Mid Volume (dB)
slider10:0<-24,24,0.1>Side Volume (dB)
slider11:0<0,4,1{Stereo,Mid+,Side+,Mid,Side}>Processing Mode

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
b1Env1 = -exp(slider4 / srate );
a0Env1 = 1.0 + b1Env1;
b1Env2 = -exp(slider5 / srate );
a0Env2 = 1.0 + b1Env2;
b1Env3 = -exp(slider6 / srate );
a0Env3 = 1.0 + b1Env3;
gain = 0;

g_maxx = 2000;         // number of points on axis X
g_framerate = 1500;    // graph frame rate
g_n = 4;               // number of graphs
freembuf(g_maxx*g_n + 1);
memset(0, 0, g_maxx*g_n);
g_idx = 0;

g_spf = srate / g_framerate;  // samples per frame
g_sample = 0;

midVol = 1.0;
sideVol = 1.0;
processingMode = 0;

// Additional variables for Mid/Side processing
midEnv1 = 0; midEnv2 = 0; midEnv3 = 0;
sideEnv1 = 0; sideEnv2 = 0; sideEnv3 = 0;
midGain = 0; sideGain = 0;
midGainLast = 0; sideGainLast = 0;
midGainV = 1.0; sideGainV = 1.0;

@slider
attack=slider1/100;
sustain=slider2/50;
vol = 2^(slider3/6);

b1Env1 = -exp(slider4 / srate );
a0Env1 = 1.0 + b1Env1;
b1Env2 = -exp(slider5 / srate );
a0Env2 = 1.0 + b1Env2;
b1Env3 = -exp(slider6 / srate );
a0Env3 = 1.0 + b1Env3;

gain_decay = slider8 / srate;

// Mid/Side volume controls
midVol = 10^(slider9/20);
sideVol = 10^(slider10/20);
processingMode = slider11;

@sample
// ===== INPUT PROCESSING =====
inputL = spl0;
inputR = spl1;

// Convert to Mid/Side for processing
midInput = (inputL + inputR) * 0.5;
sideInput = (inputL - inputR) * 0.5;

// ===== TRANSIENT DETECTION AND PROCESSING =====
processingMode == 0 ? ( // Stereo - process full stereo signal
    maxSpls = max(abs(inputL), abs(inputR));
    env1 = sqrt(tmpEnv1 = a0Env1*maxSpls - b1Env1*tmpEnv1);
    env2 = sqrt(tmpEnv2 = a0Env2*maxSpls - b1Env2*tmpEnv2);
    env3 = sqrt(tmpEnv3 = a0Env3*maxSpls - b1Env3*tmpEnv3);

    gainAttack = log(max(env2/env1,1))*attack;
    gainSustain = log(max(env3/env1,1))*sustain;

    gainLast = gain;
    gain = gainAttack + gainSustain;
    slider7 ? gain = gain >= 0 ?
      max(gain, gainLast - gain_decay) :
      min(gain, gainLast + gain_decay);

    gainV = exp(gain) * vol;

    // Apply to both channels
    outputL = inputL * gainV;
    outputR = inputR * gainV;

) : processingMode == 1 ? ( // Mid+ - process only Mid channel, mix with unprocessed Side
    // Process Mid channel
    midMaxSpls = abs(midInput);
    midEnv1 = sqrt(midTmpEnv1 = a0Env1*midMaxSpls - b1Env1*midTmpEnv1);
    midEnv2 = sqrt(midTmpEnv2 = a0Env2*midMaxSpls - b1Env2*midTmpEnv2);
    midEnv3 = sqrt(midTmpEnv3 = a0Env3*midMaxSpls - b1Env3*midTmpEnv3);

    midGainAttack = log(max(midEnv2/midEnv1,1))*attack;
    midGainSustain = log(max(midEnv3/midEnv1,1))*sustain;

    midGainLast = midGain;
    midGain = midGainAttack + midGainSustain;
    slider7 ? midGain = midGain >= 0 ?
      max(midGain, midGainLast - gain_decay) :
      min(midGain, midGainLast + gain_decay);

    midGainV = exp(midGain) * vol;

    // Apply processing only to Mid, leave Side unchanged
    midOutput = midInput * midGainV;
    sideOutput = sideInput; // Side passes through unchanged

    // Convert back to stereo
    outputL = midOutput + sideOutput;
    outputR = midOutput - sideOutput;

) : processingMode == 2 ? ( // Side+ - process only Side channel, mix with unprocessed Mid
    // Process Side channel
    sideMaxSpls = abs(sideInput);
    sideEnv1 = sqrt(sideTmpEnv1 = a0Env1*sideMaxSpls - b1Env1*sideTmpEnv1);
    sideEnv2 = sqrt(sideTmpEnv2 = a0Env2*sideMaxSpls - b1Env2*sideTmpEnv2);
    sideEnv3 = sqrt(sideTmpEnv3 = a0Env3*sideMaxSpls - b1Env3*sideTmpEnv3);

    sideGainAttack = log(max(sideEnv2/sideEnv1,1))*attack;
    sideGainSustain = log(max(sideEnv3/sideEnv1,1))*sustain;

    sideGainLast = sideGain;
    sideGain = sideGainAttack + sideGainSustain;
    slider7 ? sideGain = sideGain >= 0 ?
      max(sideGain, sideGainLast - gain_decay) :
      min(sideGain, sideGainLast + gain_decay);

    sideGainV = exp(sideGain) * vol;

    // Apply processing only to Side, leave Mid unchanged
    midOutput = midInput; // Mid passes through unchanged
    sideOutput = sideInput * sideGainV;

    // Convert back to stereo
    outputL = midOutput + sideOutput;
    outputR = midOutput - sideOutput;

) : processingMode == 3 ? ( // Mid - process and output ONLY Mid channel (mono)
    // Process Mid channel
    midMaxSpls = abs(midInput);
    midEnv1 = sqrt(midTmpEnv1 = a0Env1*midMaxSpls - b1Env1*midTmpEnv1);
    midEnv2 = sqrt(midTmpEnv2 = a0Env2*midMaxSpls - b1Env2*midTmpEnv2);
    midEnv3 = sqrt(midTmpEnv3 = a0Env3*midMaxSpls - b1Env3*midTmpEnv3);

    midGainAttack = log(max(midEnv2/midEnv1,1))*attack;
    midGainSustain = log(max(midEnv3/midEnv1,1))*sustain;

    midGainLast = midGain;
    midGain = midGainAttack + midGainSustain;
    slider7 ? midGain = midGain >= 0 ?
      max(midGain, midGainLast - gain_decay) :
      min(midGain, midGainLast + gain_decay);

    midGainV = exp(midGain) * vol;

    // Apply processing only to Mid, discard Side completely
    midOutput = midInput * midGainV;
    
    // Output only Mid signal to both channels (mono)
    outputL = midOutput;
    outputR = midOutput;

) : ( // Side - process and output ONLY Side channel (stereo difference)
    // Process Side channel
    sideMaxSpls = abs(sideInput);
    sideEnv1 = sqrt(sideTmpEnv1 = a0Env1*sideMaxSpls - b1Env1*sideTmpEnv1);
    sideEnv2 = sqrt(sideTmpEnv2 = a0Env2*sideMaxSpls - b1Env2*sideTmpEnv2);
    sideEnv3 = sqrt(sideTmpEnv3 = a0Env3*sideMaxSpls - b1Env3*sideTmpEnv3);

    sideGainAttack = log(max(sideEnv2/sideEnv1,1))*attack;
    sideGainSustain = log(max(sideEnv3/sideEnv1,1))*sustain;

    sideGainLast = sideGain;
    sideGain = sideGainAttack + sideGainSustain;
    slider7 ? sideGain = sideGain >= 0 ?
      max(sideGain, sideGainLast - gain_decay) :
      min(sideGain, sideGainLast + gain_decay);

    sideGainV = exp(sideGain) * vol;

    // Apply processing only to Side, discard Mid completely
    sideOutput = sideInput * sideGainV;
    
    // Output only Side signal (stereo difference)
    outputL = sideOutput;
    outputR = -sideOutput;
);

// ===== MID/SIDE VOLUME ADJUSTMENT =====
// Apply final Mid/Side volume controls to the processed signal
midSignal = (outputL + outputR) * 0.5;
sideSignal = (outputL - outputR) * 0.5;

midSignal *= midVol;
sideSignal *= sideVol;

// Final stereo output
spl0 = midSignal + sideSignal;
spl1 = midSignal - sideSignal;

// ===== VISUALIZATION DATA =====
play_state == 1 || play_state == 5 ? (g_sample = (g_sample + 1) % g_spf) == 0 ? (
    processingMode == 0 ? (
        0[g_idx] = env1;
        1[g_idx] = env2;
        2[g_idx] = env3;
        3[g_idx] = gain/5 + 0.5;
    ) : processingMode == 1 ? (
        0[g_idx] = midEnv1;
        1[g_idx] = midEnv2;
        2[g_idx] = midEnv3;
        3[g_idx] = midGain/5 + 0.5;
    ) : processingMode == 2 ? (
        0[g_idx] = sideEnv1;
        1[g_idx] = sideEnv2;
        2[g_idx] = sideEnv3;
        3[g_idx] = sideGain/5 + 0.5;
    ) : processingMode == 3 ? (
        0[g_idx] = midEnv1;
        1[g_idx] = midEnv2;
        2[g_idx] = midEnv3;
        3[g_idx] = midGain/5 + 0.5;
    ) : (
        0[g_idx] = sideEnv1;
        1[g_idx] = sideEnv2;
        2[g_idx] = sideEnv3;
        3[g_idx] = sideGain/5 + 0.5;
    );
    g_idx = (g_idx + g_n) % (g_maxx*g_n);
);

@gfx 600 300

function g_y(y) (
  gfx_h - gfx_h * y;
);

function graph(idx, r, g, b, legend) (
  gfx_r = r; gfx_g = g; gfx_b = b; gfx_a = 1;

  gfx_x = 34; gfx_y = 4 + idx * (gfx_texth+4);
  gfx_drawstr(legend);
  gfx_y += 3;
  gfx_line(2, gfx_y, 30, gfx_y);

  i = 0;
  ii = g_idx;
  gfx_x = 0;
  gfx_y = idx[ii];
  while (
    x = i*gfx_w/g_maxx;
    gfx_a = (idx == 3) || (idx != 0 && idx[ii] > 0[ii]) ? 1 : 0.5;
    gfx_lineto(x, g_y(idx[ii]));
    idx != 0 && idx != 3 && idx[ii] > 0[ii] ? gfx_line(x, g_y(0[ii]), x, g_y(idx[ii]));
    i += 1;
    ii = (ii + g_n) % (g_maxx*g_n);
    i < g_maxx;
  );
);

gfx_clear = 0;
graph(2, 0, 0, 1, "Sustain (when exceeds Transient)");
graph(1, 1, 0, 0, "Attack (when exceeds Transient)");
graph(0, 1, 1, 1, "Transient");
graph(3, 0, 1, 0, "Gain");

// Display current processing mode with visual feedback
gfx_r = 1; gfx_g = 1; gfx_b = 1; gfx_a = 1;
gfx_x = gfx_w - 150;
gfx_y = 4;
processingMode == 0 ? (
    gfx_drawstr("Mode: Stereo");
    gfx_r = 1; gfx_g = 1; gfx_b = 1; // White for stereo
) : processingMode == 1 ? (
    gfx_drawstr("Mode: Mid+");
    gfx_r = 1; gfx_g = 0.5; gfx_b = 0; // Orange for Mid+
) : processingMode == 2 ? (
    gfx_drawstr("Mode: Side+");
    gfx_r = 0; gfx_g = 0.7; gfx_b = 1; // Blue for Side+
) : processingMode == 3 ? (
    gfx_drawstr("Mode: Mid");
    gfx_r = 1; gfx_g = 0.8; gfx_b = 0; // Bright orange for Mid
) : (
    gfx_drawstr("Mode: Side");
    gfx_r = 0; gfx_g = 0.9; gfx_b = 1; // Bright blue for Side
);

// Display which channel is being processed
gfx_y += gfx_texth + 2;
processingMode == 0 ? gfx_drawstr("Processing: L+R") :
processingMode == 1 ? gfx_drawstr("Processing: Mid (mixed)") :
processingMode == 2 ? gfx_drawstr("Processing: Side (mixed)") :
processingMode == 3 ? gfx_drawstr("Processing: Mid (only)") :
gfx_drawstr("Processing: Side (only)");

mouse_x >= 0 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h ? (
  val = 3[(floor(mouse_x*g_maxx/gfx_w)*g_n + g_idx) % (g_maxx*g_n)];
  gfx_circle(mouse_x, g_y(val), 2, 1, 1);

  val = (val-0.5)*5;
  gfx_y = 4; gfx_x = gfx_w*3/4;
  val >= 0 ? gfx_drawstr("+");
  gfx_drawnumber(val, 2); gfx_drawstr("dB");
);
